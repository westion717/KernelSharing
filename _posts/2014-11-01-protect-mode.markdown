---
layout: post
title:  保护模式
categories: day05
---
##内容概述
---

- 保护模式介绍
- GDT
- 装载GDT
- 编译、链接、装载的补充
- GRUB加载内核之前的各种状态信息

##知识点分析
---

####保护模式介绍

**下面我们要介绍保护模式。我们介绍的原则是用多少介绍多少，所以介绍的不够全面。细节还需读者查阅相关资料。**


在介绍保护模式（protected mode）之前，先说一下实模式（real mode）。因为我们的学x86架构的计算机启动时先是处在实模式，然后被切换到保护模式。现在大部分的主流操作系统都是工作在保护模式下的。  
实模式中寻址方式（找寻内存的方式）是通过段地址乘16（用16进制表示就是末尾加个0）再加上偏移地址得到。那么为什么要用这样的方法来寻址呢？因为在386以前，寄存器只有16位，而地址线20位（286以前）或24位（286）。所以如果不采用上诉的`段寄存器x16＋偏移地址`的寻址方法，就用一个寄存器作寻址，那么寻址范围只有2的16次方，也就是64KB，达不到2的20次方，1MB。这样，内存就被我们分段了，每一段有2的16次方，64KB。另一方面，我们把`段寄存器x16`叫做段基址，那么最后的物理地址便是

	物理地址＝段基址＋偏移地址
	段基址＝段寄存器 x 16
	

这里顺便要明确几个地址的概念。偏移地址也叫逻辑地址。**段基址＋偏移地址**得到的是虚拟地址，也叫**线性地址**。**在没有开启分页的时候，线性地址就是物理地址**，若开启分页那么线性地址与物理地址数值并不一定相同，还需要经过转换。关于分页也是保护模式下的知识，之后碰到再说。物理地址就是实际中内存的地址。
  
段地址存在段寄存器中。段寄存器有CS,DS,ES,SS。386及以后还有GS,FS。偏移地址则可以存在于其他的非段寄存器中，AX,BX,CX,DX,SP,BP,SI,DI,IP。386及以后的32位通用寄存器名字要在之前加上'E',变EAX,EBX,ECX,EDX,ESI,EDI,ESP,EBP,EIP。但是为什么386及以后段寄存器还是16位呢？因为为了与之前的CPU兼容，之前的程序可以运行在新的CPU上。所以段寄存器还是16位。  
**为了简化处理，我们之后讨论的CPU是以32位为例子，64位的CPU是可以兼容32位的，所以程序是可以运行在64位机上**。    
所以现在应该明白了第二次课中，CPU开机启动时的读的第一条指令的地址是怎么计算出来的。CPU刚启动时，所有段地址为0，除了CS
是`0xFFFF`,所有非段寄存也是0。所以EIP＝0，所以物理地址就是

	add = CS x 16 + IP(EIP) = 0xFFFF0



接下来，我们把目光集中在80386及以后的CPU上。我们知道80386及以后的CPU的段寄存器之外的寄存器已经到了32位，地址线也到了32位，那么已经匹配。就不需要那么复杂的寻址方式了。但是为了保持兼容性，所以实模式还是采用了`段寄存器 x 16 ＋ 偏移地址`的寻址方式。那么这样的寻址方式已经能够提供和地址线匹配的寻址空间，为何要放着简简单单的实模式不用，要设计如此复杂的保护模式呢？  
在实模式CPU上编程，系统程序员要考虑如何避免用户进程访问系统空间，如何禁止进程A非法访问进程B的空间；应用程序员要精确计算程序大小避免自己的程序占用其他进程的空间，但对于运行时才能知道所需内存的程序却几乎无能为力，导致有时候程序干脆无法运行……实模式的优点恰恰是它的缺点：它很简单，但过于简单，难以支持现代操作系统提供多进程的能力。所以需要保护模式。  
顾名思义，这个模式起到最大的意义就是保护。相对于实模式，保护模式提供了一系列复杂的机制，其中最重要的是分段、分页以及中断。其中分段和分页都是为了给编写应用程序的程序员提供更好的地址抽象和内存管理。而这些改变都是从寻址方式改变开始。所以接下来我们要改变我们之前的寻址公式。

	物理地址＝段基址＋偏移地址
	段基址＝段寄存器 x 16

先来说几个概念术语。保护模式中，我们把上面公式中的`物理地址`要改为`线性地址`，因为在保护模式中，这不是正真的内存的物理地址。如果保护模式中开启了分页功能那么这个线性地址就还不是物理地址。关于分页我们以后再说。保护模式中，上诉公式中段基址的计算方法也需要修改。那么段基址怎么获得呢？这就要引出了一个东西叫**GDT**(global descriptor table),**全局描述符表**。

####GDT

原来我们段基址的获得是`段寄存器 x 16`得到一个20位的段基址。现在我们不用这个方法。我们去GDT这张表里去找段的基地址。怎么找呢？我们把这个段寄存器中的值当作索引。比如段寄存器中的值为3，那么就找到GDT中第四条（从0开始）。而GDT中每一条条目中就记录了段基址是多少。所以每一个条目就能表示一个段。那么这个在段寄存器中的索引就叫做段选择子。当然这个段选择字不仅仅包括用来找GDT中找位置的索引了。它的结构如下

![selector](http://mykernel.qiniudn.com/day05_selector.png)

前13位作为索引，后三位中。0位到1位是表示请求特权级，RPL（request privilege level）。是保护模式中用于保护作用的一个参数。具体以后再介绍。2位是表示这个选择子是GDT的选择子还是LDT的选择子。LDT是跟GDT类似的东西，只不过它是局部的，叫做local descriptor table。具体以后再介绍。所以作为GDT的选择子，2位置0
。   
介绍完了选择子的结构，我们再来介绍一下GDT中每一个条目，也就是全局描述符。GDT则是描述符的一个数组。概念别搞混了。

直接上图
![gd](http://mykernel.qiniudn.com/day05_globaldescriptor.png)

一个条目占8个字节，也就是64位。结构如上图。段基址占了32位，但是不是连续空间。段的长度用段界限来表示。段界限等于段长度减1。因为这样段尾的内存单元索引刚好是段基址加上长度所表示。段界限也是非连续位数来表示的。之所以弄成这样复杂，也是历史问题，为了和之前的程序兼容。

我们来解释一下byte5。P位表示这个段是不是在内存中，若果在内存中就置为1。DPL是段权限级别，取值从0到3，权限级别依次降低。系统内核的代码或数据都是运行在Ring0，而用户的应用则运行在Ring3。其他的特权级别不是特别重要。现在的主要的操作系统只使用0和3这两个级别。分级的原因不用说，就是为了保护内核咯。当用户级别的应用试图访问系统级别的代码或数据，就会发生错误。还有某些**重要的指令**只有高特权级的代码可以使用，比如开关中断。中断是一个操作系统中特别重要的部分。我们之后的课程会说明。S位是表示这个段是代码段／数据段（s=1）还是系统段／门（s=0）。

type占的四位如下说明

![descriptortype](http://mykernel.qiniudn.com/day05_descriptortype.png)


我们再看byte6。低四位不用说，是段长度的高4位，段长度一共有20位。G位表示段的粒度。0代表粒度为`字节`，1代表粒度为`4KB`。我们的段界限不是只有20位吗，所以2的20次方只有1M，这样每个段最多只能寻址1M的空间，但是我们要每个段能寻址4GB的空间，所以粒度要选择4KB，这样20位中每一位代表4KB，而不是1个字节，这样每段就可以达到4GB的空间。5位为0。AVL位保留，可被软件修改，一般我们置0就好。D/B位。在可执行段中,D为1,表示使用32位地址,32/8位操作数;为0表示使用16位地址,16/8位操作数。在由SS寻址的段描述符(堆栈段)中,D为1表示隐含操作(如PUSH/POP)使用ESP为堆栈指针,为0使用SP。在向低扩展的存储段中,D为1,表示段的上限为4G;为0上限为64K。


####装载gdt
OK，descriptor已经描述清楚了。然后我们来说一下descriptor的数组，也就是GDT。  
这张表的第一项，就是索引0，是留空的。这是规定。所以就把它64位都置0。  
那么CPU如何找到整个表呢。这里就要介绍一个结构,我们把它叫做GDTR,就是Global Descriptor Table Register。这个寄存器里记录了GDT的位置和大小。GDTR，有48位，低16位放GDT的大小`(字节－1)`，高32位放GDT的地址。所以GDT最多只能有2的16次方个描述符。  
装载gdt需要用到汇编语句`lgdt [gdtr]`。gdtr是保存GDTR内容的一个结构的首地址。

####编译、链接、装载的补充
我们知道，我们的内核程序是一个可执行二进制文件，格式是ELF。编译的过程是将每个单独的源文件编译生成`.o`后缀的目标文件。但是这样的单独的模块是无法构成一个完整的程序的，其中还是涉及到相互的调用。所以需要链接过程，将各模块链接生成单个的可执行文件。链接的过程中就需要对模块相互的调用做`重定位`。比如你在A文件中，调用了B文件中定义的函数，那么在编译A的时候并不知道B函数的调用的地址。所以我们只能暂时搁置在哪儿。等到把A和B链接在一块的时候，再去修改A中调用函数B的地址,这个过程叫做`重定位`。而标号和函数是一样的，函数名其实就是标号。  
生成的ELF格式的文件中，不光是可执行的文件，还有其他的一些描述信息。比如程序加载的`虚拟地址`。还记不记得我们链接的时候有一个链接脚本。里面指定了程序的加载的位置，就是`address=100000`这句。它使得链接之后生成的ELF文件中描述程序加载的`虚拟地址`为1M。注意这里是虚拟地址，我们还没有开启分页，所以这里的虚拟地址即是`物理地址`。**另外，标号链接之后也就代表虚拟地址咯,还有所有的变量也是被编译成地址。**  
**注意，这是在elf的格式的目标文件链接成的elf可执行文件。其他文件类型或在还没链接的目标文件中标号并不是虚拟地址，是单文件中与第一条指令的偏移地址**
ELF格式的文件头里定义了程序的虚拟地址，这样加载程序的加载器就能根据ELF文件头的描述信息来加载程序到指定位置。在我们的教程中，加载内核的工作是有GRUB完成。所以GRUB会分析kernel的文件头，来将kernel加载到指定的位置（虚拟地址为1M处）。由于没有开启分页，所以kernel被加载到内存物理地址为1M处。  

####GRUB加载内核之前的各种状态信息
我们介绍了这么多的保护模式的知识，也知道计算机刚启动时是运行在实模式的，那为什么我的内核一开始没有做进入保护模式的工作呢？答案是GRUB已经帮我们做了。GRUB在载入我们内核并运行之前CPU处于如下状态。

	CS指向一个以0为基址，4GB－1为界限的代码段描述符。
	DS，SS，ES，FS和GS指向一个以0为基址，4GB－1为界限的数据段描述符。
	A20地址线被打开
	CR0的PE位置位，PG位清除，即保护模式开启，分页关闭。

所以GRUB帮我们进入了保护模式，并且初始化了GDT其中的两个段，一个是代码段，一个是数据段。A20地址线被打开。（关于A20地址线是一个历史遗留问题。只有打开之后，才能访问1M以后的内存。）。分页未开启


但是，GDT的内容不在内核中，在GRUB程序中。这样GDT不受我们控制，是我们不希望的。因为我们后续还需要对GDT做修改，并且GDT在GRUB我们不知道具体的位置，就无法保护，一旦GDT受到破坏，整个计算机就崩了。一般GRUB在完成加载内核的工作之后，就没有存在在内存中的意义了，所以在内存中占的空间就可以被其他程序使用。所以我们要把GDT转到我们的程序中来。

综上，我们需要在我们的程序里建立GDT，然后用`lgdt [gdtr]`指令，装载我们的GDT，然后把各个段寄存器指向我们GDT中的数据段，最后还需要使用jmp跳转到我们的代码段来更新一下cs寄存器。

##具体操作

---


在`source`目录建立`gdt.c`

{% highlight c linenos%}

/*gdt.c*/

#include <gdt.h>

/* GDT条目结构
 *  __attribute__((packed)) 结构是防止编译器优化
 * 成员从上到下地址以此递增，从低位到高位
 */
PRIVATE struct gdt_entry
{
	u16 limit_low;
	u16 base_low;
	u8 base_middle;
	u8 access;
	u8 granularity;
	u8 base_high;
}__attribute__((packed));

/* GDTR的机构 limit记得是长度－1*/
PRIVATE struct gdt_ptr
{
	u16 limit;
	u32 base;
}__attribute__((packed));

/* GDT条目 */
PRIVATE struct gdt_entry gdt[3];
/*GDTR结构*/
PUBLIC struct gdt_ptr gp;

/* 设置gdt中条目内容 
 *  num是对于的条目号，从0开始
 */
PRIVATE void gdt_set_gate(int num, u32 base, u32 limit, u8 access, u8 gran);

/* 这个函数定义在汇编中，调用lgdt更新gdt
 * extern 来表示这个函数在汇编中
 * 其实这里extern 加不加都可
 */
extern void gdt_flush();

PRIVATE void gdt_set_gate(int num, u32 base, u32 limit, u8 access, u8 gran)
{
	/* 设置基地址 */
	gdt[num].base_low = (base & 0xFFFF);
	gdt[num].base_middle = (base >> 16) & 0xFF;
	gdt[num].base_high = (base >> 24) & 0xFF;

	/* 设置段长
	   limit只使用低20位
	 */

	gdt[num].limit_low = (limit & 0xFFFF);
	gdt[num].granularity = ((limit >> 16) & 0x0F);

	/* 设置权限粒度等属性 */
	/* gran用高4位*/
	gdt[num].granularity |= (gran & 0xF0);
	gdt[num].access = access;
}

PUBLIC void gdt_install()
{
	/* 设置GDTR结构 */
	gp.limit = (sizeof(struct gdt_entry) * 3) - 1;
	gp.base = (u32)&gdt;

	/* 0号描述符要为null*/
	gdt_set_gate(0, 0, 0, 0, 0);
	/*
	 *  1号描述符。是一个代码段，基址为0,范围4GB,使用4KB的粒度
	 *  使用32位操作符。相关位的属性含义请参看上文的介绍
	 */
	gdt_set_gate(1, 0, 0xFFFFFFFF, 0x9A, 0xCF);

	/*  2号条目。这是一个数据段，其他属性与上面代码段一样 */
	gdt_set_gate(2, 0, 0xFFFFFFFF, 0x92, 0xCF);

	/* 更新gdt */
	gdt_flush();
}

{% endhighlight %}


一些函数和结构的定义定义成私有，也就是静态的，是为了不被外界调用。关于gdt的管理只由这一个文件来处理。

和之前一样，我们要建立gdt的头文件`gdt.h`

{% highlight c linenos%}

#include <type.h>

#ifndef __GDT_H
#define __GDT_H

/* 载入新的GDT，函数定义在汇编中。在供给main函数调用*/
PUBLIC void gdt_install();


#endif
{% endhighlight %}

因为只有一个函数是要被外界函数调用的，所以在头文件里声明了。

最后我们的`gdt_flush`函数还要在汇编中定义。要在`start.asm`的`jmp $` 之后添加以下的代码


{% highlight as linenos%}
; 以下代码我们更新我们的GDT，使得代码段和数据段等段寄存器都更新为我们自己设置的代码段和数据段
global gdt_flush     ; 导出该函数，以便在C中调用，C中用extern void gdt_flush();
extern gp            ; 引入GDTR结构的变量gp，在C中定义
gdt_flush:
    lgdt [gp]        ; 载入GDT，GDTR内容用gp所指向的内容更新
    mov ax, 0x10      ; 0x10 是数据段的选择子的值，前13位的值是2，索引对应是条目2
    mov ds, ax
    mov es, ax
    mov fs, ax
    mov gs, ax
    mov ss, ax        ; 除CS其余段寄存器都指向上述数据段
    jmp 0x08:flush2   ; 同理0x08 是代码段选择子，前13位的值是1，索引对应GDT中的条目1
                      ; 这里`选择子:标号`的jmp形式，使用的是绝对地址跳转。因为标号已经是虚拟地址，所以代码段的基址要为0才能定位到正确位置。在C的gdt.c中定义的代码段就是基址为0
flush2:
    ret               ; 返回到C代码中
    
{% endhighlight %}

最后在main函数中调用`gdt_install`函数

{% highlight c linenos%}

/*main.c*/

#include <scrn.h>
#include <gdt.h>

int main()
{
		 gdt_install();
        init_video();
        puts("hello world\n");
        puts("hello world\n");
        settextcolor(12,13);
        puts("hello world\n");
    for (;;);
return 0;
}
{% endhighlight %}

我们在gdt安装之后，执行了换字体颜色的函数，然后输出另一颜色的helloworld。如果显示成功那么证明gdt_install中的gdt_flush函数执行成功，成功定位到了我们正在执行代码，并成功返回到C代码。


最后记得在makefile中添加目标文件gdt.o还有编译语句。运行`build.sh`,成功编译构建出iso文件。然后按之前一样运行，得到如下效果。

![gdt_install](http://mykernel.qiniudn.com/day05_gtd_install.png)

OK,成功。(最后一行的helloword有点刺眼)

到这里我们的GDT就初始化好了，意味着我们将保护模式中最重要的东西搬到了内核，这样就算GRUBdown了我们也不怕了。

##注意提醒
---
- GDT初始化是保护模式中最重要的一件事，所以我们最好把它放在main函数中第一个调用的函数。
